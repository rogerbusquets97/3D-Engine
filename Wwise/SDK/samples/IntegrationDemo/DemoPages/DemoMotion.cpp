/*******************************************************************************
The content of this file includes portions of the AUDIOKINETIC Wwise Technology
released in source code form as part of the SDK installer package.

Commercial License Usage

Licensees holding valid commercial licenses to the AUDIOKINETIC Wwise Technology
may use this file in accordance with the end user license agreement provided 
with the software or, alternatively, in accordance with the terms contained in a
written agreement between you and Audiokinetic Inc.

  Version: v2017.1.3  Build: 6377
  Copyright (c) 2006-2017 Audiokinetic Inc.
*******************************************************************************/

// DemoMotion.cpp
/// \file
/// Defines all methods declared in DemoMotion.h.

#include "stdafx.h"

#include <AK/SoundEngine/Common/AkSoundEngine.h>    // Sound engine
#include <AK/MotionEngine/Common/AkMotionEngine.h>	// Motion Engine (required only for playback of Motion objects)

#include "../WwiseProject/GeneratedSoundBanks/Wwise_IDs.h"		// IDs generated by Wwise
#include "Menu.h"
#include "DemoMotion.h"
#include "IntegrationDemo.h"
#include "InputMgr.h"


/////////////////////////////////////////////////////////////////////
// DemoMotion Constant Member Initialization
/////////////////////////////////////////////////////////////////////

const AkGameObjectID DemoMotion::EMITTER_OBJ_FOR_PLAYER[MAX_PLAYERS] = { 200, 300, 400, 500 };
const AkGameObjectID DemoMotion::LISTENER_OBJ_FOR_PLAYER[MAX_PLAYERS] = { 201, 301, 401, 501 };


//These defines are there as default for all platforms.
//Some platforms have a different way of specifying the player ID or the controller output type.  Check in ..\[PlatformName]\Plarform.h
#ifndef GET_PLAYER_ID
#define GET_PLAYER_ID(_index) _index
#endif

/////////////////////////////////////////////////////////////////////
// DemoMotion Public Methods
/////////////////////////////////////////////////////////////////////

DemoMotion::DemoMotion( Menu& in_ParentMenu ):MultiplayerPage( in_ParentMenu, "Motion Demo" )
{
	m_szHelp  = "This multiplayer demonstration shows Wwise's capabilities to also emit output "
				"as motion, in this case through a controller's force feedback mechanism.\n\n"
				"Select and press \"Close Door\" to simulate a door closing in the environment. "
				"This should emit a force feedback reaction felt by all players.\n\n"
				"Select and press \"Shoot Gun\" to simulate firing a weapon. This should emit a "
				"force feedback reaction only for the player who shot the weapon.\n\n"
				"NOTE: A player using a keyboard (Windows) should plug in a gamepad to participate.";
}

bool DemoMotion::Init()
{
	// ###### NOTE ######
	// The Motion plugin and Motion device type (eg. Rumble capable gamepads) have previously
	// been registered with the engine. See IntegrationDemo::InitWwise for details.

	// Load the Motion sound bank
	AkBankID bankID; // not used
	if ( AK::SoundEngine::LoadBank( "Motion.bnk", AK_DEFAULT_POOL_ID, bankID ) != AK_Success )
	{
		SetLoadFileErrorMessage( "Motion.bnk" );
		return false;
	}

	// Register the "door" game object and set listeners 0-6 to respond to it
	AK::SoundEngine::RegisterGameObj(GAME_OBJECT_DOOR);
	for (AkUInt32 i = 0; i < MAX_PLAYERS; ++i)
	{
		AK::SoundEngine::RegisterGameObj(LISTENER_OBJ_FOR_PLAYER[i]);
	}
	AK::SoundEngine::SetListeners(GAME_OBJECT_DOOR, LISTENER_OBJ_FOR_PLAYER, MAX_PLAYERS);

	// Setup the motion devices and objects for all the players
	if ( ! SetupMotionDevices() )
	{
		SetErrorMessage( "Could not setup the motion devices" );
		return false;
	}

	// Initialize the page
	return MultiplayerPage::Init();
}

void DemoMotion::Release()
{
	// Unregister the "Door" game object
	AK::SoundEngine::UnregisterGameObj( GAME_OBJECT_DOOR );
	
	// Unregister the players
	for ( int i = 0; i < MAX_PLAYERS; i++ )
	{
		if ( m_bPlayerConnected[i] )
		{
			// Remove the motion device for the player
			AK::MotionEngine::RemovePlayerMotionDevice( (AkUInt8) i, AKCOMPANYID_AUDIOKINETIC, AKMOTIONDEVICEID_RUMBLE );

#ifdef CONTROLLER_OUTPUT	//See Platform.h
			AK::SoundEngine::RemoveSecondaryOutput(GET_PLAYER_ID(i), CONTROLLER_OUTPUT(i));
#endif
		}

		// Unregister the player's game object
		AK::SoundEngine::UnregisterGameObj(EMITTER_OBJ_FOR_PLAYER[i]);
	}

	// Unload the soundbank
	AK::SoundEngine::UnloadBank( "Motion.bnk", NULL );

	// Release the Page
	MultiplayerPage::Release();
}


/////////////////////////////////////////////////////////////////////
// DemoMotion Private Methods
/////////////////////////////////////////////////////////////////////

void DemoMotion::InitControls()
{
	ButtonControl* newBtn;

	// Create the controls
	for ( int i = 0; i < MAX_PLAYERS; i++ )
	{
		// Add player i's Door Slide button
		newBtn = new ButtonControl( *this );
		newBtn->SetLabel( "Close Door" );
		newBtn->SetDelegate( (PageMFP)&DemoMotion::DoorSlide_Pressed );
		m_Controls[i].push_back( newBtn );

		// Add player i's Gun Shot button
		newBtn = new ButtonControl( *this );
		newBtn->SetLabel( "Shoot Gun" );
		newBtn->SetDelegate( (PageMFP)&DemoMotion::GunShot_Pressed );
		m_Controls[i].push_back( newBtn );
	}
}

void DemoMotion::OnPlayerConnect( int in_iPlayerIndex )
{
	const UniversalGamepad* gp = m_pParentMenu->Input()->GetGamepad( (AkUInt16) in_iPlayerIndex + 1 ); // UniversalInput is 1-based.

	// Register an object for this player
	AK::SoundEngine::RegisterGameObj( EMITTER_OBJ_FOR_PLAYER[in_iPlayerIndex]);

	// Register the player's motion device
	if ( AK::MotionEngine::AddPlayerMotionDevice( (AkUInt8) in_iPlayerIndex, AKCOMPANYID_AUDIOKINETIC, AKMOTIONDEVICEID_RUMBLE, gp->GetExtraParam() ) != AK_Success )
	{
		SetErrorMessage( "Could not set up the motion device for new player" );
	}

	// The player i is represented by listener i, make sure he's listening to himself too
#ifdef CONTROLLER_OUTPUT	//See Platform.h
	AK::SoundEngine::AddSecondaryOutput(GET_PLAYER_ID(in_iPlayerIndex), CONTROLLER_OUTPUT(in_iPlayerIndex), &LISTENER_OBJ_FOR_PLAYER[in_iPlayerIndex], 1);
#endif
	
	AK::SoundEngine::SetListeners(EMITTER_OBJ_FOR_PLAYER[in_iPlayerIndex], &LISTENER_OBJ_FOR_PLAYER[in_iPlayerIndex], 1);
	AK::MotionEngine::SetPlayerListener((AkUInt8)in_iPlayerIndex, LISTENER_OBJ_FOR_PLAYER[in_iPlayerIndex]);

	// The listener i receives audio and motion events
	if (AK::SoundEngine::SetListenerPipeline(LISTENER_OBJ_FOR_PLAYER[in_iPlayerIndex], true, true) != AK_Success)
	{
		return;
	}
}

void DemoMotion::OnPlayerDisconnect( int in_iPlayerIndex )
{
	// The player's listener no longer receives motion data..
	AK::SoundEngine::SetListenerPipeline( in_iPlayerIndex, true, false );

	// Remove the motion device for the player
	AK::MotionEngine::RemovePlayerMotionDevice( (AkUInt8) in_iPlayerIndex, AKCOMPANYID_AUDIOKINETIC, AKMOTIONDEVICEID_RUMBLE );

#ifdef CONTROLLER_OUTPUT	//See Platform.h
	AK::SoundEngine::RemoveSecondaryOutput(GET_PLAYER_ID(in_iPlayerIndex), CONTROLLER_OUTPUT(in_iPlayerIndex));
#endif


	// Unregister the player's game object
	AK::SoundEngine::UnregisterGameObj( EMITTER_OBJ_FOR_PLAYER[in_iPlayerIndex] );
}

bool DemoMotion::SetupMotionDevices()
{
	for ( int i = 0; i < MAX_PLAYERS && m_bPlayerConnected[i]; i++ )
	{
		const UniversalGamepad* gp = m_pParentMenu->Input()->GetGamepad( (AkUInt16) i + 1 ); // UniversalInput is 1-based.

		// Register an object for this player
		AK::SoundEngine::RegisterGameObj(EMITTER_OBJ_FOR_PLAYER[i]);
		AK::SoundEngine::RegisterGameObj(LISTENER_OBJ_FOR_PLAYER[i]);

		// Register the player's motion device
		if ( AK::MotionEngine::AddPlayerMotionDevice( (AkUInt8) i, AKCOMPANYID_AUDIOKINETIC, 
			AKMOTIONDEVICEID_RUMBLE, gp->GetExtraParam() ) != AK_Success )
		{
			SetErrorMessage( "Could not set up the motion device for new player" );
		}

		// The player i is represented by listener i, make sure he's listening to himself too
#ifdef CONTROLLER_OUTPUT	//See Platform.h
		AK::SoundEngine::AddSecondaryOutput(GET_PLAYER_ID(i), CONTROLLER_OUTPUT(i), &LISTENER_OBJ_FOR_PLAYER[i], 1 );
#endif
		
		AK::SoundEngine::SetListeners( EMITTER_OBJ_FOR_PLAYER[i], &LISTENER_OBJ_FOR_PLAYER[i], 1 );
		AK::MotionEngine::SetPlayerListener((AkUInt8)i, LISTENER_OBJ_FOR_PLAYER[i]);

		// The listener i receives audio and motion events
		if (AK::SoundEngine::SetListenerPipeline(LISTENER_OBJ_FOR_PLAYER[i], true, true) != AK_Success)
		{
			return false;
		}
	}

	return true;
}

void DemoMotion::DoorSlide_Pressed( void*, ControlEvent* )
{
	AK::SoundEngine::PostEvent( AK::EVENTS::DOORSLIDING, GAME_OBJECT_DOOR );
}

void DemoMotion::GunShot_Pressed( void*, ControlEvent* in_pEvent )
{
	// Fire the gun for the player who shot
	if( in_pEvent->iPlayerIndex >= 1 && in_pEvent->iPlayerIndex <= MAX_PLAYERS )
		AK::SoundEngine::PostEvent( AK::EVENTS::GUNFIRE, EMITTER_OBJ_FOR_PLAYER[in_pEvent->iPlayerIndex - 1] );
}
